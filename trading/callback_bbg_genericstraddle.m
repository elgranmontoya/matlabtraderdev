function callback_bbg_genericstraddle(obj,event,varargin)
p = inputParser;
p.CaseSensitive = false;p.KeepUnmatched = true;
p.addParameter('Connection',{},@(x)validateattributes(x,{'blp','cell'},{},'Connection'));
p.addParameter('Product',{},@(x)validateattributes(x,{'cStraddle','cProduct','cell'},{},'Product'));
p.addParameter('Vol',{},@(x)validateattributes(x,{'struct','cVol''cell'},{},'Vol'));
p.addParameter('Mode','realtime',@ischar);
p.parse(varargin{:});
conn = p.Results.Connection;
product = p.Results.Product;
iv = p.Results.Vol;
mode = p.Results.Mode;

if ~(strcmpi(mode,'realtime') || ...
        strcmpi(mode,'backtest') || ...
        strcmpi(mode,'demo')) 
    error('callback_bbg_genericstraddle:invalid mode input!')
end

if isempty(conn) && strcmpi(mode,'realtime')
    error('callback_bbg_genericstraddle:invalid connection input!')
end

if isempty(product)
    error('callback_bbg_genericstraddle:invalid product input!')
end

if isempty(iv)
    error('callback_bbg_genericstraddle:invalid vol input!')
end

dateRunning = floor(datenum(event.Data.time));
if isholiday(dateRunning) && strcmpi(mode,'realtime')
    %nothing to do when it is a public holiday
    fprintf('%s:not a business date\n',datestr(event.Data.time));
    return
end

if isa(product,'cStraddle')
    instrument = product.Underlier;
else
    error('internal error')
    %not implemented yet
end
    
if isstruct(iv)
    vol = iv.Vol;
else
    error('internal error!')
    %not implemented yet
end

if isempty(obj.UserData)
    %first time to run the callback function
    %1.do a valuation of the straddle
    strike = product.Strike;
    rate = 0;
    tau = length(product.TradingDays)/252;
    yield = 0;
    notional = product.Notional;
    stradPremium = valstraddle(strike,strike,rate,tau,vol,yield,notional);
    %2.get the market quote when first time to run the callback function
    if strcmpi(mode,'realtime')
        data = getdata(conn,instrument.BloombergCode,'px_last');
        refSpot = data.px_last;
    elseif strcmpi(mode,'demo')
        fprintf('running demo mode!\n');
        refSpot = 1.0;
    else
        error('internal error')
    end
    stradPremium = stradPremium/refSpot;
    tp = cTradingPlatform;
    strat = cStrategySyntheticStraddle;
    product.Strike = refSpot;
    strat = strat.addstraddle(product);
        
    ud = struct('Premium',stradPremium,...
        'UnwindPnL',0,...
        'RunningPnL',0,...
        'Strategy',strat,...
        'TradingPlatform',tp);
    obj.UserData = ud;
end

ud = obj.UserData;
premium = ud.Premium;
pnlUnwind = ud.UnwindPnL;
pnlRunning = ud.RunningPnL;
pnl = pnlUnwind + pnlRunning;

if pnl < 0 && abs(pnl) >= premium
    %shall check whether all positions are closed in case the stoploss
    %breaches
    return
end

strat = ud.Strategy;
tp = ud.TradingPlatform;

if strcmpi(mode,'realtime')
    data = getdata(conn,instrument.BloombergCode,{'bid','ask'});
    bid = data.bid;
    ask = data.ask;
elseif strcmpi(mode,'demo')
    bid = 1.0;
    ask = 1.0;
else
    error('internal error')
end
mid = 0.5*(bid+ask);
    
t = datenum(event.Data.time);

underlierinfo = struct('Instrument',instrument,...
    'Time',t,...
    'Bid',bid,...
    'Ask',ask,...
    'Price',mid);

%note:orders are generated by strategy class with initial status 'unknown'
%as we don't know whether the order can be traded or not
orders = strat.genorder('underlierinfo',underlierinfo,...
    'underliervol',iv,...
    'tradingplatform',tp);
   
unwindPnL = 0;
for i = 1:length(orders)
    tradeid = length(tp.gettrades)+1;
    [tp,~,order,unwindPnL] = tp.sendorder('order',orders{i},'tradeid',tradeid);
    order.print;
end


%update UserData
ud.UnwindPnL = unwindPnL;
ud.RunningPnL = tp.calcpnl(underlierinfo);
ud.TradingPlatform = tp;

obj.UserData = ud;

if strcmpi(mode,'demo')
    fprintf('%s:callback_bbg_genericstraddle excecuted!\n',datestr(event.Data.time));
elseif strcmpi(mode,'realtime')
    tp.printpositions;
    fprintf('%s:pnl>>>%4.2f\n',datestr(event.Data.time),ud.UnwindPnL+ud.RunningPnL);
end

end